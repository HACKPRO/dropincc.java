package com.github.pfmiles.dropincc.impl.llstar;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.github.pfmiles.dropincc.DropinccException;
import com.github.pfmiles.dropincc.impl.EleType;
import com.github.pfmiles.dropincc.impl.GruleType;
import com.github.pfmiles.dropincc.impl.TokenType;
import com.github.pfmiles.dropincc.impl.kleene.CKleeneNode;
import com.github.pfmiles.dropincc.impl.kleene.KleeneCrossType;
import com.github.pfmiles.dropincc.impl.kleene.KleeneStarType;
import com.github.pfmiles.dropincc.impl.kleene.KleeneType;
import com.github.pfmiles.dropincc.impl.kleene.OptionalType;

/**
 * The whole ATN network for the analyzing grammar
 * 
 * @author pf-miles
 * 
 */
public class Atn {
    // all states contained in this ATN network
    private Set<AtnState> states = new HashSet<AtnState>();
    // grule type to its corresponding start state mapping
    private Map<GruleType, AtnState> gruleTypeStartStateMapping = new HashMap<GruleType, AtnState>();
    // atn state to its belonging grule type mapping
    private Map<AtnState, GruleType> stateGruleTypeMapping = new HashMap<AtnState, GruleType>();
    // normal state naming sequence
    private SeqGen normalStateSeq = new SeqGen();

    /**
     * Return all target AtnState of the specified transition edge.
     * 
     * @param edge
     * @return
     */
    public Set<AtnState> getAllDestinationsOf(Object edge) {
        Set<AtnState> ret = new HashSet<AtnState>();
        for (AtnState state : states) {
            if (state.getTransitions().containsKey(edge))
                ret.addAll(state.getTransitions().get(edge));
        }
        return ret;
    }

    /**
     * Return the start state of the specified grule type.
     * 
     * @param gruleType
     * @return
     */
    public AtnState getStartState(GruleType gruleType) {
        return this.gruleTypeStartStateMapping.get(gruleType);
    }

    /**
     * turn this ATN network to a dot file
     * 
     * @return
     */
    public String toDot() {
        // TODO to be implemented
        return toString();
    }

    public String toString() {
        return "Atn(" + this.states + ")";
    }

    /**
     * Return the gruleType the specified atnState belongs to
     * 
     * @param state
     * @return
     */
    public GruleType getGruleTypeByAtnState(AtnState state) {
        return this.stateGruleTypeMapping.get(state);
    }

    /**
     * create a start state for the specified grule
     * 
     * @param grule
     * @return
     */
    public AtnState newStartStateForGrule(GruleType grule) {
        AtnState ret = new AtnState("R" + grule.getDefIndex());
        this.states.add(ret);
        this.stateGruleTypeMapping.put(ret, grule);
        this.gruleTypeStartStateMapping.put(grule, ret);
        return ret;
    }

    /**
     * create a end state for the specified grule
     * 
     * @param grule
     * @return
     */
    public AtnState newEndStateForGrule(GruleType grule) {
        AtnState ret = new AtnState("R" + grule.getDefIndex() + "_end", true);
        this.states.add(ret);
        this.stateGruleTypeMapping.put(ret, grule);
        return ret;
    }

    /**
     * create 'alt state' for the specified grule
     * 
     * @param grule
     * @param i
     * @return
     */
    public AtnState newAltStateForGrule(GruleType grule, int i) {
        AtnState ret = new AtnState("R" + grule.getDefIndex() + "_" + i);
        this.states.add(ret);
        this.stateGruleTypeMapping.put(ret, grule);
        return ret;
    }

    /**
     * Create a 'normal'(not start or end state or alt state of a grule) state
     * in the ATN, the names of these normal states are generated by a number
     * sequence global to the whole ATN network.
     * 
     * @param grule
     *            the grule the state belongs to
     * @return
     */
    public AtnState newAtnState(GruleType grule) {
        AtnState ret = new AtnState(String.valueOf(this.normalStateSeq.next()));
        this.states.add(ret);
        this.stateGruleTypeMapping.put(ret, grule);
        return ret;
    }

    /**
     * Generate all transitions from start to end with the specified edges
     * 
     * @param start
     * @param edges
     * @param end
     * @param grule
     * @param kleeneTypeToNode
     */
    public void genTransitions(AtnState start, List<EleType> edges, AtnState end, GruleType grule, Map<KleeneType, CKleeneNode> kleeneTypeToNode) {
        AtnState curState = start;
        EleType lastEdge = edges.get(edges.size() - 1);
        // iterate from 0 to size-1(except the last one)
        for (int i = 0; i < edges.size() - 1; i++) {
            EleType edge = edges.get(i);
            if (edge instanceof TokenType || edge instanceof GruleType) {
                AtnState nextState = this.newAtnState(grule);
                curState.addTransition(edge, nextState);
                curState = nextState;
            } else if (edge instanceof KleeneStarType) {
                this.genTransitions(curState, kleeneTypeToNode.get((KleeneStarType) edge).getContents(), curState, grule, kleeneTypeToNode);
            } else if (edge instanceof KleeneCrossType) {
                List<EleType> content = kleeneTypeToNode.get((KleeneCrossType) edge).getContents();
                AtnState nextState = this.newAtnState(grule);
                this.genTransitions(curState, content, nextState, grule, kleeneTypeToNode);
                curState = nextState;
                this.genTransitions(curState, content, curState, grule, kleeneTypeToNode);
            } else if (edge instanceof OptionalType) {
                AtnState nextState = this.newAtnState(grule);
                curState.addTransition(edge, nextState);
                curState.addTransition(Constants.epsilon, nextState);
                curState = nextState;
            } else {
                throw new DropinccException("Illegal transition edge of ATN: " + edge);
            }
        }
        curState.addTransition(lastEdge, end);
    }
}
